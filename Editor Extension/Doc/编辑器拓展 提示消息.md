> 《调教UE5》系列记录的是笔者在开发UE引擎中总结的些许经验。文中所有观点和结论仅代表个人见解，作为自学笔记和日后反思之参考，亦可能存在谬误或过时之处。如有错漏和不当，恳请多加指正。


---


[Helo：《调教UE5：编辑器拓展指南》开篇及索引](https://zhuanlan.zhihu.com/p/604684703)


---


# 目录

> **1. 一点提示：   AddOnScreen ~ **♡
> **2. 悄悄记下：   UE_LOG ~ **♡
> **3. 偷偷打开...    Dialog ~ **♡
> **4. 弹出来了!!!   Notify ~ **♡


---


$$
\large \textbf{小小的提示，满满的心思。} \\
$$


---


目前，本指南基于 **UE5.0.3** 引擎版本进行编写，读者需前往下载对应的引擎版本，以免在尝试过程中因引擎版本差异造成不必要的麻烦。




# 一点提示：AddOnScreen ~ ♡

来稍稍探索一下将消息打印到屏幕的方法。




## AddOnScreenDebugMessage

最常用到的一种将消息打印到屏幕的方法是 AddOnScreenDebugMessage()，它经常像下面这样使用。

```cpp
GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::White, TEXT("要在屏幕上打印的消息。"));
```

第一个参数是 Key。如果 Key 设置为 -1，则每次执行这行代码时，都会向屏幕添加一条新消息。

例如，如果将其添加到 Tick() 函数中，屏幕很快就会充斥着这些消息流。如果 Key 是一个正整数（Key 的类型是uint64），则每个有相同 Key 的新消息会替换掉相同 Key 的旧消息。例如，如果在 Tick() 上调用上述函数，并将其 Key 修改为1，则游戏中屏幕上只会显示一条消息，因为每次新调用都会简单地替换它。

第二个参数是将显示消息的时间（以秒为单位）。它是 float 类型。

第三个参数是确定文本颜色的参数。

第四个参数是消息本身。注意，整个字符串只能占用一个参数，因此，要打印有多个参数组成的复杂内容，可以使用 `FString::Printf()` 。 

```cpp
float x = 10.f;
int32 y = 5;
GEngine->AddOnScreenDebugMessage(-1, 5.f, FColor::Red, FString::Printf(TEXT("打印一些不同类型的值: x = %f, y = %d"), x, y));
```

AddOnScreenDebugMessage() 还有两个可选参数。

第五个参数是一个布尔值，用于确定新消息是显示在顶部（如果为 true）还是显示在底部（如果为 false）。这仅适用于 Key 值设置为 -1 的情况。

第六个参数是确定文本比例的 2D 矢量。如果打印到屏幕上的消息太小而无法轻松阅读，或者它们太大而占用太多屏幕空间，这将非常有用。




${♡☘♡☘♡  \quad今天的捉弄结束了 \quad ♡☘♡☘♡}\\$ 




## Viewport Stats Subsystem

Viewport Stats Subsystem 提供将消息添加到当前视口的功能。

Viewport Stats Subsystem 打印的消息是持续的，相当于每 Tick 做 AddOnScreenDebugMessage。它通过回调的方式来控制要打印的消息和是否打印该消息。

以下是来自最近很火的 OpenAI 强行杜撰的使用方法，紧跟时事拉出来批评一下这个嘴硬 AI。

![](https://pica.zhimg.com/v2-ffd35fac0636f5629afc0628fba5d316_r.jpg)

![](https://pic1.zhimg.com/v2-028bbe252f8a92db879b0cc5b91f50e8_r.jpg)




## 创建 UMessageClass

截止本指南编写之时，似乎并没有使用该子系统的示例可以参考，此处给出一个使用示例。

我们创建一个新的“CustomMessage”模块，作为与 Message 相关的辅助类。

关于C++项目的创建细节，可以参考 [《调教UE5：编辑器拓展指南》编辑器拓展基础](https://zhuanlan.zhihu.com/p/605181368) 中第一小节。

![](https://pic3.zhimg.com/v2-1cad177b331950094dafdc052c407658_r.jpg)




CustomMessage.h 和 CustomMessage.cpp 中除了实现模块外不做任何事情。

```cpp
// CustomMessage.h

#pragma once

#include "Modules/ModuleInterface.h"

class FCustomMessageModule : public IModuleInterface
{
public:
	
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
	virtual ~FCustomMessageModule() {}
};


// CustomMessage.cpp

#pragma once

#include "CustomMessage.h"

IMPLEMENT_MODULE(FCustomMessageModule, CustomMessage)

void FCustomMessageModule::StartupModule(){}

void FCustomMessageModule::ShutdownModule(){}
```




在 CustomMessage.Build.cs 中添加“UnrealEd”依赖项。

```csharp
// CustomMessage.Build.cs

using UnrealBuildTool;

public class CustomMessage : ModuleRules
{
	public CustomMessage(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;
	
		PublicDependencyModuleNames.AddRange(new string[]
		{ 
			"Core", 
			"CoreUObject", 
			"Engine", 
			"InputCore",
			"UnrealEd",
		});

		PrivateDependencyModuleNames.AddRange(new string[] {  });
	}
}
```




来到 ExtendEditor.uproject，设置模块类型和启动顺序。

```csharp
// ExtendEditor.uproject

{
	"FileVersion": 3,
	"EngineAssociation": "5.0",
	"Category": "",
	"Description": "",
	"Modules": [
		{
			"Name": "ExtendEditor",
			"Type": "Runtime",
			"LoadingPhase": "Default"
		},
		
		...

		{
			"Name": "CustomMessage",
			"Type": "Editor",
			"LoadingPhase": "Default"
		}
	],
	"Plugins": [
		{
			"Name": "ModelingToolsEditorMode",
			"Enabled": true,
			"TargetAllowList": [
				"Editor"
			]
		}
	]
}
```




我们还可以暂时在 ExtendEditorEditor.Target.cs 中添加该模块，这样在没有任何模块依赖这个模块时也可以正常编辑。

```csharp
// ExtendEditorEditor.Target.cs

using UnrealBuildTool;
using System.Collections.Generic;

public class ExtendEditorEditorTarget : TargetRules
{
	public ExtendEditorEditorTarget( TargetInfo Target) : base(Target)
	{
		Type = TargetType.Editor;
		DefaultBuildSettings = BuildSettingsVersion.V2;
		ExtraModuleNames.AddRange( new string[]
		{
			"ExtendEditor",
			...
			"CustomMessage",
		} );
	}
}
```




正确设置完这些，就可以开始制作自己的 MessageClass 类了。

首先我们需要一个回调函数，这个函数会被绑定到 Viewport Stats Subsystem。函数的功能是每个 Tick 时传递要打印的消息和颜色，并通过返回值的形式控制是否要打印消息。

我们可以通过改变 UMessageClass 中成员变量的状态，来控制消息的打印。

```cpp
// MessageClass.h

#pragma once

#include "CoreMinimal.h"
#include "MessageClass.generated.h"

UCLASS()
class CUSTOMMESSAGE_API UMessageClass : public UObject
{
	GENERATED_BODY()

public:
	/** 用于 UViewportStatsSubsystem 的回调函数 */
	UFUNCTION()
	bool MessageCallback(FText& OutText, FLinearColor& OutColor);

	/** 设置显示内容 */
	void SetMessage(FText InText, FLinearColor InColor);

	/** 打开和关闭消息显示 */
	void ToggleDisplay();

	/** 负责将 MessageCallback 绑定到 ViewportStatsSubsystem */
	void BindToViewportStatsSubsystem();

	/** 查询绑定状态 */
	bool IsBind();

private:
	
	FText Text = FText();
	FLinearColor Color = FLinearColor();
	bool bShouldDisplay = false;

	bool bIsBind = false;
};
```




实现 UMessageClass 类。

```cpp
// MessageClass.cpp

#pragma once

#include "MessageClass.h"

#include "LevelEditorViewport.h"
#include "Engine/ViewportStatsSubsystem.h"


bool UMessageClass::MessageCallback(FText& OutText, FLinearColor& OutColor)
{
	OutText = Text;
	OutColor = Color;
	return bShouldDisplay;
}

void UMessageClass::SetMessage(FText InText, FLinearColor InColor)
{
	Text = InText;
	Color = InColor;
}

void UMessageClass::ToggleDisplay()
{
	bShouldDisplay = !bShouldDisplay;
}

void UMessageClass::BindToViewportStatsSubsystem()
{
	if(UViewportStatsSubsystem* ViewportSubsystem = 
		GEditor->GetLevelViewportClients()[0]->GetWorld()->GetSubsystem<UViewportStatsSubsystem>())
	{
		FViewportDisplayCallback Callback;
		Callback.BindDynamic(this, &UMessageClass::MessageCallback);
		ViewportSubsystem->AddDisplayDelegate(Callback);
	}

	bIsBind = true;
}

bool UMessageClass::IsBind()
{
	return bIsBind;
}
```







${♡☘♡☘♡  \quad今天的捉弄结束了 \quad ♡☘♡☘♡}\\$ 




## 使用 UMessageClass

接下来到 ExtendMenuBase 模块中使用 UMessageClass。

我们来到之前添加第一个 ToolBar 按钮的地方，相关的内容在 [《调教UE5：编辑器拓展指南》编辑器拓展基础](https://zhuanlan.zhihu.com/p/605181368) 中“使用 ExtendEditorStyle 模块”这一小节。




首先在 ExtendMenuBase.Build.cs 里添加“CustomMessage”模块依赖。

来到 ExtendMenuBase.h 中，在 FExtendMenuBase 里添加 UMessageClass 成员变量。

```cpp
// ExtendMenuBase.h

#pragma once

#include "Modules/ModuleInterface.h"

class FExtendMenuBase : public IModuleInterface
{
public:
	
	virtual void StartupModule() override;
	virtual void ShutdownModule() override;
	virtual ~FExtendMenuBase() {}

private:
	...

private:
	class UMessageClass* MessageDelegate = nullptr;
};
```




来到 ExtendMenuBase.cpp 中，找到 FExtendMenuBase::StyleButtonAction() 并拓展。

```cpp
// ExtendMenuBase.cpp

#pragma once

#include "ExtendMenuBase.h"

...
#include "MessageClass.h"

...

void FExtendMenuBase::StyleButtonAction()
{
	UE_LOG(LogTemp, Warning, TEXT("StyleButtonAction is called."))

	if(!MessageDelegate)
	{
		MessageDelegate = NewObject<UMessageClass>();
		MessageDelegate->AddToRoot();
		MessageDelegate->SetMessage(
		FText::FromString("This is a Binded Message."), FLinearColor::White);

		if(!MessageDelegate->IsBind())
		{
			MessageDelegate->BindToViewportStatsSubsystem();
		}
	}

	MessageDelegate->ToggleDisplay();
}
```




重新编译并重启编辑器，点击 ToolBar 上的按钮，就可以控制消息的开关了。







${♡☘♡☘♡  \quad今天的捉弄结束了 \quad ♡☘♡☘♡}\\$ 




# 悄悄记下：UE_LOG ~ ♡

Logs 在运行时的特定时间保留事件、函数调用、变量值等的有序记录。这通常以文本形式保存在日志文件中。对于软件开发人员来说，这是一个非常宝贵的工具，尤其是在调试时，因为它可以提供有关代码在任何给定时刻正在做什么的详细信息。良好的用例包括确保执行某些代码块、检查函数之间传递的数据值以及报告潜在问题。




## UE_LOG

一个简单的日志消息示例如下。

```cpp
// UE_LOG(CategoryName, Verbosity, Format, ...)
UE_LOG(LogTemp, Warning, TEXT("要记录在日志中的消息。"));
```

UE_LOG 是将日志消息输出到日志文件中的宏。它采用的第一个输入参数是日志记录类别的名称。引擎中已经内置了许多这些类别，在 CoreGlobals.h 中可以查看。我们也可以定义自己的类别，在本章的“自定义 UE_LOG 类别”小节中会介绍它。

![](https://picx.zhimg.com/v2-3276c58bde62592ab0e9db11a8349e53_r.jpg)




第二个参数是 Log 的详细级别。它定义了此条 Log 的显示方式和特殊行为。在本章的“Log 详细级别”小节中会介绍它。

最后一个参数是文本消息本身。如果字符串使用某些 printf 格式说明符，则可以添加更多参数。参考示例如下。

```cpp
// UE_LOG()示例

// Logging an FString
FString MyString = "Something";
UE_LOG(LogTemp, Warning, TEXT("The Actor's name is %s"), *MyString);

// Logging a Bool
bool bMyBool = ture;
UE_LOG(LogTemp, Warning, TEXT("The boolean value is %s"), ( bMyBool ? TEXT("true") : TEXT("false") ));

// Logging an Integer
int32 MyInt = 432;
UE_LOG(LogTemp, Warning, TEXT("The integer value is: %d"), MyInt);

// Logging a Float
float MyFloat = 3.14;
UE_LOG(LogTemp, Warning, TEXT("The float value is: %f"), MyFloat);

// Logging an FVector
FVector MyVector(1.f, 2.f, 3.f);
UE_LOG(LogTemp, Warning, TEXT("The vector value is: %s"), *MyVector.ToString());

// Logging with Multiple Specifiers
UE_LOG(LogTemp, Warning, TEXT("Current values are: vector %s, float %f, and integer %d"), *MyVector.ToString(), MyFloat, MyInt);
```







${♡☘♡☘♡  \quad今天的捉弄结束了 \quad ♡☘♡☘♡}\\$ 




## Logs 文件位置

**Editor Session Logs**

此 Logs 将在运行 UE5Editor.exe 时生成或在特定项目中生成。这些是最重要的 Logs。

| Log Name                                                      | Windows location        | Mac Location                                    |
| ------------------------------------------------------------- | ----------------------- | ----------------------------------------------- |
| UE4.log<br>UE4-backup-YYYY.DD.MM-HR.Mn.Sc.log                 | Engine\Saved\Logs\      | ~/Library/Logs/Unreal Engine/Editor/            |
| ProjectName.log<br>ProjectName-backup-YYYY.DD.MM-HR.Mn.Sc.log | ProjectName\Saved\Logs\ | ~/Library/Logs/Unreal Engine/ProjectNameEditor/ |




**Game Logs**

此 Logs 将在运行烘焙/打包的项目（ProjectName.exe或 ProjectName.app）时生成。如果运行打包的游戏时出现问题，检查此 Logs。

| Log Name        | Windows location                       | Mac Location                |
| --------------- | -------------------------------------- | --------------------------- |
| ProjectName.log | WindowsNoEditor/ProjectName/Saved/Logs | ~/Library/Logs/ProjectName/ |




**Build/Cook/Package Logs**

这些日志在构建/烹饪/打包项目时生成。File >Package > Platform、编辑器启动、UFE sessions。

| Log Name                | Windows location                                                                                                                    | Mac Location                                 |
| ----------------------- | ----------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------- |
| Cook.txt<br>UAT_Log.txt | P4 - Engine\Programs\AutomationTool\Saved\Logs<br><br><br>Binary - %USERPROFILE%\AppData\Roaming\Unreal Engine\AutomationTool\Logs\ | ~/Library/Logs/Unreal Engine/LocalBuildLogs/ |




**Crash Logs**

这些是创建并上传到CrashReporter的崩溃日志。

| Log Name                                           | Windows location                                                                                                 | Mac Location                                                                                                                                                                                                                                     |
| -------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| diagnostics.txt<br>minidump.dmp<br>ProjectName.log | %USERPROFILE%\AppData\Local\Microsoft\Windows\WER\ReportQueue<br><br><br>(C:\Users\UserName\AppData 不可见，通过地址栏输入) | P4 - Engine/Saved/Crashes/CrashReport-ProjectName/<br><br><br>Binary: ~/Library/Application Support/Epic/Unreal Engine/4.X/Saved/Crashes/CrashReport-ProjectName/ <br><br><br>(/Users/yourusername/Library 是不可见的，按住alt键并从查找器菜单中选择Go-&gt;Library) |




${♡☘♡☘♡  \quad今天的捉弄结束了 \quad ♡☘♡☘♡}\\$ 




## 自定义 UE_LOG 类别

我们平时使用的 LogTemp 意味着该信息是临时日志信息。UE5 也定义了一些 UE_LOG 类别，比如 LogActor，用来输出 Actor 类相关的调试信息，比如 LogAnimation，用来输出 Animation 的调试信息，基本上，UE5 给每个模块定义了一个单独的 UE_LOG 类别，其他的我们可以打开 Output Log 窗口查看。现在我们来自定义自己的 UE_LOG 类别。

要定义自己的 UE_LOG 类别，需要在头文件中加入如下声明宏。

```cpp
DECLARE_LOG_CATEGORY_EXTERN(CategoryName, DefaultVerbosity, CompileTimeVerbosity)
```

- **CategoryName **是你定义的 UE_LOG 类别 的名字。
- **DefaultVerbosity **是 Log 详细级别，在 Log 详细级别没有被 .ini 文件或者命令行中指定时使用。
- **CompileTimeVerbosity **是编译时最大的 Log 详细级别，任何大于这个详细级别的 Log 都不会被编译。

然后，还需要在.cpp文件中加入如下定义宏。这里的 CategoryName 参数要与声明中的 CategoryName 对应。

```cpp
DEFINE_LOG_CATEGORY(CategoryName);
```




下面是一个简单示例。

```cpp
// ExtendMenuBase.h
...
// Verbosity is Verbose
DECLARE_LOG_CATEGORY_EXTERN(MyLog, Verbose, All)



// ExtendMenuBase.cpp
...

DEFINE_LOG_CATEGORY(MyLog)

...
void FExtendMenuBase::StyleButtonAction()
{
	// Level Log SHOW in OutputLog
	UE_LOG(MyLog, Log, TEXT("Verbosity is Log"))
	// Level Verbose SHOW in OutputLog
	UE_LOG(MyLog, Verbose, TEXT("Verbosity is Verbose"))
	// Level VeryVerbose HIDE in OutputLog
	UE_LOG(MyLog, VeryVerbose, TEXT("Verbosity is VeryVerbose"))
}
```







${♡☘♡☘♡  \quad今天的捉弄结束了 \quad ♡☘♡☘♡}\\$ 




## Log 详细级别

你可以在游戏的不同方面使用不同的 UE_LOG 类别，这给了你额外的信息，因为 UE_LOG 在显示消息时会打印出 UE_LOG 类别。

假如游戏中的某个系统经常出问题，在调试当时你可能想要获取详细的 Log 信息，但是当你完成调试时，你可能就不需要它们了，你该如何做呢？Log 详细级别可以解决这个问题。

我们可以通过声明在 UE_LOG 类别时指定其默认的 DefaultVerbosity，以及更改 .ini 文件或命令行来实时控制某个 UE_LOG 类别的 Log 详细级别，以关闭该类别的某些 Log 输出。

```cpp
// ExtendMenuBase.h
...
// Verbosity is VeryVerbose
DECLARE_LOG_CATEGORY_EXTERN(MyLog, VeryVerbose, All)



// ExtendMenuBase.cpp
...

DEFINE_LOG_CATEGORY(MyLog)

...
void FExtendMenuBase::StyleButtonAction()
{
	// Level Log SHOW in OutputLog
	UE_LOG(MyLog, Log, TEXT("Verbosity is Log"))
	// Level Verbose SHOW in OutputLog
	UE_LOG(MyLog, Verbose, TEXT("Verbosity is Verbose"))
	// Level VeryVerbose SHOW in OutputLog
	UE_LOG(MyLog, VeryVerbose, TEXT("Verbosity is VeryVerbose"))
}
```

例如，在这个示例中，在我们调试完后就不需要 Verbose 和 VeryVerbose 两个详细级别的 Log 输出了，因此可以将 `DECLARE_LOG_CATEGORY_EXTERN(MyLog, VeryVerbose, All)` 中的“VeryVerbose”修改为“Log”以关闭后面两个 Log。

```cpp
// ExtendMenuBase.h
...
// Verbosity is VeryVerbose
DECLARE_LOG_CATEGORY_EXTERN(MyLog, Log, All)



// ExtendMenuBase.cpp
...

DEFINE_LOG_CATEGORY(MyLog)

...
void FExtendMenuBase::StyleButtonAction()
{
	// Level Log SHOW in OutputLog
	UE_LOG(MyLog, Log, TEXT("Verbosity is Log"))
	// Level Verbose HIDE in OutputLog
	UE_LOG(MyLog, Verbose, TEXT("Verbosity is Verbose"))
	// Level VeryVerbose HIDE in OutputLog
	UE_LOG(MyLog, VeryVerbose, TEXT("Verbosity is VeryVerbose"))
}
```




Log 详细级别可以让你更容易地控制输出信息，这允许你在代码中保持最详尽的 Log 语句，并在你不需要它们时禁用它们，每个 UE_LOG 声明了该 Log 属于哪个等级。Log 详细级别通过每个 Log 基础控制，每个 Log 的信息显示被四件事控制：

- 编译时指定（CompileTimeVerbosity）
- 默认指定（DefaultVerbosity）
- 初始化时变更 Verbosity（ .ini 文件）
- 运行时变更 Verbosity（命令行）

如果一个 Log 语句比它编译时的信息更冗余，它甚至不会被编译进游戏代码，Log 详细级别会被设置成默认指定，稍后可以在 Engine.ini 文件中变更，或者通过命令行变更，一旦游戏或编辑器运行起来，那它就没办法改变Log 详细级别（不确定是不是这样）。




下面是可用的日志信息显示等级。

- **Fatal**，Fatal 等级的 Log 总是被输出到控制台和 Logs 文件，且会导致程序崩溃。有时这是一种有效的提示手段，以绝对禁止一些不希望的操作事项。
- **Error**，Error 等级的 Log 被输出到控制台和 Logs 文件，它默认是以红颜色显示的。
- **Warning**，Warning 等级的 Log 被输出到控制台和 Logs 文件，它默认以黄颜色显示的。
- **Display**，Display 等级的 Log 会被输出到控制台和 Logs 文件。
- **Log**，Log 等级的 Log 会被输出到 Logs 文件，但不会被输出到游戏里的控制台，它们仍能在编辑器里通过Output Log窗口被看到。
- **Verbose**，Verbose 等级 Log 会被输出到 Logs 文件，但不会被输出到游戏里的控制台，通常用来显示详细的细节和调试。
- **VeryVerbose**，VeryVerbose 等级 Log 会被输出到 Logs 文件，但不会被输出到游戏里的控制台，通常用来显示非常详细的细节，这可能会让输出窗口被杂乱的信息填充。

对于 `DECLARE_LOG_CATEGORY_EXTERN`的 `CompileTimeVerbosity`参数，它能使用 **All **和 **NoLogging**。







${♡☘♡☘♡  \quad今天的捉弄结束了 \quad ♡☘♡☘♡}\\$ 




## Logs 调试

下面介绍有关 Logs 调试的一些方法。

## Logs 调试 ：使用 Logs

**在游戏里**

为了看到 Logs，你需要在运行游戏时使用“-Log”参数，或者在游戏中使用控制台命令`showlog`。

**在编辑器里**

Logs 信息会被输出到“Output Log”窗口中，可以通过 Window -> Developer Tools -> Output Log 打开该窗口。

如果你以 PIE 模式使用编辑器时，Logs 功能可以默认通过 Engine.ini I文件中的`GameCommandLine=-log`激活。如果看不到 Logs 输出，可以像上面在游戏中一样添加“-Log”命令行参数。




## Logs 调试 ：控制台

```text
* 指代惯例 *

它应用在控制台，ini文件或者环境变量里。

[cat] = 命令可操作的分类，对于所有的分类而言是"global"。
	对于本章“Log 详细级别”小节中的示例而言是"MyLog"。

[level] = 信息日志等级，它可以是：none,error,warning,display,log,verbose,all,default。
在启动时，默认被编译的会被ini文件里的设置重写，然后被命令行里的重写。
```




```text
Log list		- 显示所有的日志分类。
Log list [string]	- 显示包含一个子串的所有日志分类。
Log reset		- 重设所有的日志分类为启动时的默认分类。
Log [cat]		- 是否显示分类[cat]
Log [cat] off		- 禁止显示分类[cat]
Log [cat] on		- 恢复显示分类[cat]
Log [cat] [level]	- 设置分类[cat]的信息显示等级。
Log [cat] break		- 在显示分类[cat]时是否会有调试中断。
```




## Logs 调试 ：命令行

```text
在启动时应用一堆控制台命令：
-LogCmds=\"[arguments],[arguments]...\"

显示foo分类，关闭bar分类：
-LogCmds=\"foo verbose, bar off\"
```




## Logs 调试 ：环境变量

```text
任何命令行选项可通过环境变量UE-CmdLineArgs设置：

set UE-CmdLineArgs=\"-LogCmds=foo verbose breakon, bar off\"
```




## Logs 调试 ：Config 文件

```text
在Default.ini或者Engine.ini里面：

[Core.Log]
global=[default verbosity for things not listed later]
[cat]=[level]
foo=verbose break
```




示例。先配置 DefaultEngine.ini 文件。

```text
// [YourProject]/Config/DefaultEngine.ini

[Core.Log]
LogBlueprintUserMessages=none
LogDerivedDataCache=all
```

启动编辑器后在控制台输入并获得显示。

```text
Cmd: log list BlueprintUserMessages
LogBlueprintUserMessages                  NoLogging     
Cmd: log list Derived
LogAudioDerivedData                       Log           
LogDerivedDataCache                       VeryVerbose   
LogDerivedDataCacheCommandlet             Log          
```







${♡☘♡☘♡  \quad今天的捉弄结束了 \quad ♡☘♡☘♡}\\$ 




## 一点提示

下面是一些有用的小技巧。

## 一点提示：在编辑器中启用 Log 时间

在 Editor Preferences > General > Apppearance > Log Timestamp 打开。

![](https://pic4.zhimg.com/v2-c92c74dd315db237d5872f96240b0b05_r.jpg)

![](https://pic3.zhimg.com/v2-d5e311dd902f9e9bad52f752086b9ea6_r.jpg)




## 一点提示：有用的宏

```text
__FUNCTION__  - 获取当前类名和函数名。

e.g. [ int test(int x) ] -> [ __FUNCTION__ : test ]

__FUNCSIG__   - 获取当前函数签名。

e.g.[ int test(int x) ] -> [ __FUNCSIG__ : int __cdecl test(int) ]

__LINE__      - 获取调用它的代码中的当前行号。
```







${♡☘♡☘♡  \quad今天的捉弄结束了 \quad ♡☘♡☘♡}\\$ 




# 偷偷打开...  Dialog ~ ♡

通过 Dialog 打开一个对话框，能够让用户在执行某些重要操作时具有决策空间，或在执行完某些重要操作后作为结果反馈。

## FMessageDialog

FMessageDialog 给我们提供了一个预制的消息框方案，我们可以用它来快速实现生成 Message Widow。我们也可以使用 Slate 来定制自己的 Dialog，但对于本章来说它有些超纲了，后续在 Slate 专题章节我们再来详细介绍它。

FMessageDialog 只能显示文本提示消息，但它预制了各种不同的反馈窗口。

![](https://pica.zhimg.com/v2-761141a17f203e0e5352cbbc20fa6f7e_r.jpg)




接下来看 FMessageDialog 的使用方法。在 ExtendMenuBase.cpp 中添加如下内容。

```cpp
// ExtendMenuBase.cpp

#pragma once

#include "ExtendMenuBase.h"
...
#include "Misc/MessageDialog.h"

...

void FExtendMenuBase::StyleButtonAction()
{
	FText Title = FText::FromString("EAppMsgType::Ok");
	EAppReturnType::Type Return = FMessageDialog::Open(
	EAppMsgType::Ok, 
	FText::FromString("This is a Ok Dialog"), 
	&Title
	);
	
	if(Return == EAppReturnType::Ok)
	{
		Title = FText::FromString("EAppMsgType::YesNo");
		Return = FMessageDialog::Open(
			EAppMsgType::YesNo, 
			FText::FromString("This is a YesNo Dialog"), 
			&Title
			);
	}
	if(Return == EAppReturnType::Yes)
	{
		Title = FText::FromString("EAppMsgType::OkCancel");
		Return = FMessageDialog::Open(
			EAppMsgType::OkCancel, 
			FText::FromString("This is a OkCancel Dialog"), 
			&Title
			);
	}
	if(Return == EAppReturnType::Ok)
	{
		Title = FText::FromString("EAppMsgType::YesNoCancel");
		Return = FMessageDialog::Open(
			EAppMsgType::YesNoCancel,
			FText::FromString("This is a YesNoCancel Dialog"), 
			&Title
			);
	}
	if(Return == EAppReturnType::Yes)
	{
		Title = FText::FromString("EAppMsgType::CancelRetryContinue");
		Return = FMessageDialog::Open(
			EAppMsgType::CancelRetryContinue, 
			FText::FromString("This is a CancelRetryContinue Dialog"), 
			&Title
			);
	}
	if(Return == EAppReturnType::Continue)
	{
		Title = FText::FromString("EAppMsgType::YesNoYesAllNoAll");
		Return = FMessageDialog::Open(
			EAppMsgType::YesNoYesAllNoAll, 
			FText::FromString("This is a YesNoYesAllNoAll Dialog"), 
			&Title
			);
	}
	if(Return == EAppReturnType::Yes || Return == EAppReturnType::YesAll)
	{
		Title = FText::FromString("EAppMsgType::YesNoYesAllNoAllCancel");
		Return = FMessageDialog::Open(
			EAppMsgType::YesNoYesAllNoAllCancel, 
			FText::FromString("This is a YesNoYesAllNoAllCancel Dialog"), 
			&Title
			);
	}
	if(Return == EAppReturnType::Yes || Return == EAppReturnType::YesAll)
	{
		Title = FText::FromString("EAppMsgType::YesNoYesAll");
		Return = FMessageDialog::Open(
			EAppMsgType::YesNoYesAll, 
			FText::FromString("This is a YesNoYesAll Dialog"), 
			&Title
			);
	}
}
```




重新编译并重启编辑器，点击 ToolBar 上的按钮，点击确认按钮，就可以依次打开不同的 MessageDialog 了。







${♡☘♡☘♡  \quad今天的捉弄结束了 \quad ♡☘♡☘♡}\\$ 




## SCustomDialog

相比于 FMessageDialog 只能显示文字消息不同，SCustomDialog 允许显示一个 SWidget 小部件。但它同样也有一些限制，譬如它只能使用“CoreStyle”作为 IconBrush。

以下是 SCustomDialog 的使用方法。

```cpp
// ExtendMenuBase.cpp

#pragma once

#include "ExtendMenuBase.h"
...
#include "Misc/MessageDialog.h"

...

void FExtendMenuBase::StyleButtonAction()
{
#define LOCTEXT_NAMESPACE "SCustomDialog"

	// 开始构造 SCustomDialog
	TSharedRef<SCustomDialog> HelloWorldDialog = SNew(SCustomDialog)
		.Title(FText(LOCTEXT("HelloWorldTitleExample", "Hello, World!")))
		.DialogContent( // 添加 DialogContent，类型为 SWidget
			SNew(STextBlock).Text(FText::FromString("This is a Custom Dialog.")))
		.IconBrush("AppIcon")  // 只可使用 CoreStyle 中已注册的 Icon
		.Buttons({
			SCustomDialog::FButton(LOCTEXT("OK", "OK")),
			SCustomDialog::FButton(LOCTEXT("Cancel", "Cancel"))
		});

	// 显示 SCustomDialog
	HelloWorldDialog->ShowModal();

#undef LOCTEXT_NAMESPACE
}
```




重新编译并重启编辑器，点击 ToolBar 上的按钮，打开 SCustomDialog 窗口。

![](https://picx.zhimg.com/v2-b279233decea6d55548fd390140fb381_r.jpg)







${♡☘♡☘♡  \quad今天的捉弄结束了 \quad ♡☘♡☘♡}\\$ 




# 弹出来了!!!  Notify ~ ♡

通知（Notify）具有十分醒目的动画效果，因此十分适合用来作为即时提醒。通知的优点是不会打断用户的操作体验。

使用通知的方法非常简单，首先我们生成一个 FNotificationInfo，这个结构体用于储存通知的构造信息，例如通知的内容，显示时长，Icon图标等等。下表给出在 FNotificationInfo 中可以被定义的元素。

```text
// SNotificationList.h

/**如果设置，则使用此小部件覆盖通知的整个内容*/
TSharedPtr＜INotificationWidget＞ContentWidget;


/**此通知中显示的文本。适用于短通知和标题*/
TAttribute＜FText＞Text;


/**此通知中显示的可选子文本。子文本比默认文本字段小，更适合长描述*/
TAttribute＜FText＞SubText；


/**通知按钮的设置信息*/
TArray<FNotificationButtonInfo> ButtonDetails;


/**要显示在文本旁边的图标图像*/
const FSlateBrush* Image;


/**此元素的淡入持续时间*/
float FadeInDuration;


/**此元素的淡出持续时间*/
float FadeOutDuration;


/**此元素淡出前的持续时间*/
float ExpireDuration;


/**控制是否添加动画滑动*/
bool bUseThrobber;


/**控制是否显示成功和失败图标*/
bool bUseSuccessFailIcons;


/**如果为true，则将使用更大的粗体显示消息*/
bool bUseLargeFont;


/**设置此选项时，强制框的宽度，用于在文本更改时停止调整大小*/
FOptionalSize WidthOverride;


/**如果为true，则通知将在过期持续时间后自动超时。*/
bool bFireAndForget;


/**设置后，将在通知上显示一个复选框；获取当前复选框状态的句柄*/
TAttribute<ECheckBoxState> CheckBoxState;


/**设置后，将在通知上显示一个复选框；设置新复选框状态的句柄*/
FOnCheckStateChanged CheckBoxStateChanged;


/**为复选框消息显示的文本*/
TAttribute<FText> CheckBoxText;


/**设置后，将在通知的右侧显示为超链接*/
FSimpleDelegate Hyperlink;


/**要为超链接消息显示的文本*/
TAttribute<FText> HyperlinkText;


/**放置通知的特定窗口。如果为空，将使用应用程序的根窗口*/
TSharedPtr<SWindow> ForWindow;


/**如果我们应该在通知转换且性能不佳时限制编辑器，以确保用户可以看到动画，则为True*/
bool bAllowThrottleWhenFrameRateIsLow;
```




打开 ExtendMenuBase.cpp，找到 `void FExtendMenuBase::StyleButtonAction()` 添加以下内容。

```cpp
// ExtendMenuBase.h
#pragma once

#include "Modules/ModuleInterface.h"

class FExtendMenuBase : public IModuleInterface
{
	...
	int ClickCount = 0;
};


// ExtendMenuBase.cpp

#pragma once

#include "ExtendMenuBase.h"
...
#include "ExtendEditorStyle.h"
#include "UMGStyle.h"
#include "Framework/Notifications/NotificationManager.h"
#include "Widgets/Notifications/SNotificationList.h"

...

void FExtendMenuBase::StyleButtonAction()
{
	++ClickCount;
	FString str = TEXT("呀~ 被戳了 ") + FString::FromInt(ClickCount) + TEXT(" 下！~~❤");
	FText Message = FText::FromString(str);

	// 构造 FNotificationInfo
	FNotificationInfo NotifyInfo(Message);
	// 使用大字体
	NotifyInfo.bUseLargeFont = true;
	// 设定通知显示时长
	NotifyInfo.FadeOutDuration = 7.f;
	// 设定通知 Icon
	NotifyInfo.Image = FExtendEditorStyle::GetStyleSet()->GetBrush("AliceTool");

	// 利用 FNotificationInfo 发送通知
	FSlateNotificationManager::Get().AddNotification(NotifyInfo);
}
```




重新编译并重启编辑器，点击 ToolBar 上的按钮，就可以看到 Notify 弹出了。







![](https://pic4.zhimg.com/v2-ac116271a1b1fd849180954be47f3c99_r.jpg)



# 参考

1. ^C 库函数 - printf() | 菜鸟教程 [https://www.runoob.com/cprogramming/c-function-printf.html](https://www.runoob.com/cprogramming/c-function-printf.html)